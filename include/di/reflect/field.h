#pragma once

#include "di/container/string/fixed_string.h"
#include "di/function/invoke.h"
#include "di/meta/core.h"
#include "di/meta/language.h"
#include "di/vocab/tuple/tuple.h"

namespace di::reflection {
template<container::FixedString field_name, auto field_pointer>
requires(concepts::MemberObjectPointer<decltype(field_pointer)>)
struct Field {
    constexpr static auto name = field_name;
    constexpr static auto pointer = field_pointer;

    using Object = meta::MemberPointerClass<decltype(pointer)>;
    using Type = meta::MemberPointerValue<decltype(pointer)>;

    template<typename T>
    requires(concepts::Invocable<decltype(pointer), T>)
    constexpr static auto get(T&& object) -> decltype(auto) {
        return function::invoke(pointer, util::forward<T>(object));
    }

    constexpr static auto is_fields() -> bool { return false; }
    constexpr static auto is_field() -> bool { return true; }
    constexpr static auto is_enumerator() -> bool { return false; }
    constexpr static auto is_enumerators() -> bool { return false; }
    constexpr static auto is_atom() -> bool { return false; }
    constexpr static auto is_integer() -> bool { return false; }
    constexpr static auto is_bool() -> bool { return false; }
    constexpr static auto is_string() -> bool { return false; }
    constexpr static auto is_list() -> bool { return false; }
    constexpr static auto is_tuple() -> bool { return false; }
    constexpr static auto is_map() -> bool { return false; }
    constexpr static auto is_variant() -> bool { return false; }
    constexpr static auto is_box() -> bool { return false; }
    constexpr static auto is_custom_atom() -> bool { return false; }

    auto operator==(Field const&) const -> bool = default;
    auto operator<=>(Field const&) const = default;
};

template<container::FixedString field_name, auto field_pointer>
requires(concepts::MemberObjectPointer<decltype(field_pointer)>)
constexpr auto field = Field<field_name, field_pointer> {};
}

namespace di::concepts {
template<typename T>
concept Field = requires {
    { T::is_field() } -> concepts::SameAs<bool>;
} && T::is_field();
}

namespace di::reflection {
template<concepts::Constexpr ClassName, concepts::Field... Fs>
struct Fields : vocab::Tuple<Fs...> {
    constexpr static auto name = ClassName::value;

    constexpr static auto is_fields() -> bool { return true; }
    constexpr static auto is_field() -> bool { return false; }
    constexpr static auto is_enumerator() -> bool { return false; }
    constexpr static auto is_enumerators() -> bool { return false; }
    constexpr static auto is_atom() -> bool { return false; }
    constexpr static auto is_integer() -> bool { return false; }
    constexpr static auto is_bool() -> bool { return false; }
    constexpr static auto is_string() -> bool { return false; }
    constexpr static auto is_list() -> bool { return false; }
    constexpr static auto is_tuple() -> bool { return false; }
    constexpr static auto is_map() -> bool { return false; }
    constexpr static auto is_variant() -> bool { return false; }
    constexpr static auto is_box() -> bool { return false; }
    constexpr static auto is_custom_atom() -> bool { return false; }
};

namespace detail {
    template<container::FixedString class_name>
    struct MakeFieldsFunction {
        template<concepts::Field... Fs>
        constexpr auto operator()(Fs...) const {
            return Fields<meta::Constexpr<class_name>, Fs...> {};
        }
    };
}

template<container::FixedString class_name>
constexpr inline auto make_fields = detail::MakeFieldsFunction<class_name> {};
}

namespace di {
using reflection::Field;
using reflection::field;
using reflection::Fields;
using reflection::make_fields;
}
