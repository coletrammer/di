<!-- HTML header for doxygen 1.13.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />
    <meta name="generator" content="Doxygen 1.13.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>di: Static Reflection</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
 <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
    <!-- ... other metadata & script includes ... -->
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init();
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeParagraphLink.init();
    </script>
  </head>
  <body>
      <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
          <table cellspacing="0" cellpadding="0">
            <tbody>
              <tr id="projectrow">
                <td id="projectalign">
                  <div id="projectname">
                    di<span id="projectnumber">&#160;0.1.0</span
                    >
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_docs_2pages_2static__reflection.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Static Reflection</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md96"></a></p>
<h1><a class="anchor" id="autotoc_md97"></a>
Purpose</h1>
<p>Several programming utilities can become greatly simplified by using a reflection system. This allows code to introspect a type at compile time, and use this information to provide functionality. For instance, this can be used to implement automatic serialization and deserialization, or to implement enable introspection of objects at runtime. Specifically, this can be used to implement overloads of <code><a class="el" href="namespacedi.html#adcc239d82cef689530da6b8b93adec6d">di::hash</a></code>, implement <code><a class="el" href="namespacedi_1_1format.html">di::format</a></code> for a type, implement <code><a class="el" href="namespacedi.html#afc06908ae94cf039d1c2771bc765a066">di::parse</a></code> for a type, and so on.</p>
<h1><a class="anchor" id="autotoc_md98"></a>
Note on C++</h1>
<p>In the future, there will presumably be static reflection in standard C++. However, this is not yet available, but is incredibly useful. This library provides a static reflection system which can be used in the meantime.</p>
<p>Traditionally, these sorts of systems are implemented using macros. However, this library uses a different approach, which is possible due to the use of C++ 20 features (namely, string non-type template parameters).</p>
<h1><a class="anchor" id="autotoc_md99"></a>
Usage</h1>
<p>To enable static reflection for a given type, provide a hidden-friend overload of <code><a class="el" href="namespacedi.html#a8e12ec8d01827ce4f7c0738dc7a406cc">di::reflect</a></code> for the type. This can be done as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="reflect_2prelude_8h.html">di/reflect/prelude.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyType {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    <span class="keywordtype">int</span> y;</div>
<div class="line">    <span class="keywordtype">int</span> z;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> <span class="keyword">auto</span> tag_invoke(<a class="code hl_typedef" href="namespacedi_1_1types.html#aced2939f1b335fd6ed3e3def9aff824e">di::Tag&lt;di::reflect&gt;</a>, <a class="code hl_struct" href="structdi_1_1types_1_1InPlaceType.html">di::InPlaceType&lt;MyType&gt;</a>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="namespacedi.html#a1459d8183672803c685081823d4354cf">di::make_fields</a>&lt;<span class="stringliteral">&quot;MyType&quot;</span>&gt;(<a class="code hl_variable" href="namespacedi.html#a6fc25425a44d813af794d567f4764637">di::field</a>&lt;<span class="stringliteral">&quot;x&quot;</span>, &amp;MyType::x&gt;, <a class="code hl_variable" href="namespacedi.html#a6fc25425a44d813af794d567f4764637">di::field</a>&lt;<span class="stringliteral">&quot;y&quot;</span>, &amp;MyType::y&gt;,</div>
<div class="line">                                         <a class="code hl_variable" href="namespacedi.html#a6fc25425a44d813af794d567f4764637">di::field</a>&lt;<span class="stringliteral">&quot;z&quot;</span>, &amp;MyType::z&gt;);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> MyEnum { A, B, C };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_variable" href="namespacedi_1_1function_1_1tag__invoke__ns.html#a191e794736625ce4bdaaadb02b15e0e1">tag_invoke</a>(<a class="code hl_typedef" href="namespacedi_1_1types.html#aced2939f1b335fd6ed3e3def9aff824e">di::Tag&lt;di::reflect&gt;</a>, <a class="code hl_struct" href="structdi_1_1types_1_1InPlaceType.html">di::InPlaceType&lt;MyEnum&gt;</a>) {</div>
<div class="line">    <span class="keyword">using </span>enum MyEnum;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_variable" href="namespacedi.html#a7c03bea911cd4e8bf769ea17b7246998">di::make_enumerators</a>&lt;<span class="stringliteral">&quot;MyEnum&quot;</span>&gt;(<a class="code hl_variable" href="namespacedi.html#a6356665207ab38e1c7e6519f300312e8">di::enumerator</a>&lt;<span class="stringliteral">&quot;A&quot;</span>, A&gt;, <a class="code hl_variable" href="namespacedi.html#a6356665207ab38e1c7e6519f300312e8">di::enumerator</a>&lt;<span class="stringliteral">&quot;B&quot;</span>, B&gt;, <a class="code hl_variable" href="namespacedi.html#a6356665207ab38e1c7e6519f300312e8">di::enumerator</a>&lt;<span class="stringliteral">&quot;C&quot;</span>, C&gt;);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacedi_1_1function_1_1tag__invoke__ns_html_a191e794736625ce4bdaaadb02b15e0e1"><div class="ttname"><a href="namespacedi_1_1function_1_1tag__invoke__ns.html#a191e794736625ce4bdaaadb02b15e0e1">di::function::tag_invoke_ns::tag_invoke</a></div><div class="ttdeci">constexpr tag_invoke_detail::TagInvokeFn tag_invoke</div><div class="ttdef"><b>Definition</b> tag_invoke.h:22</div></div>
<div class="ttc" id="anamespacedi_1_1types_html_aced2939f1b335fd6ed3e3def9aff824e"><div class="ttname"><a href="namespacedi_1_1types.html#aced2939f1b335fd6ed3e3def9aff824e">di::types::Tag</a></div><div class="ttdeci">di::meta::Decay&lt; decltype(T)&gt; Tag</div><div class="ttdef"><b>Definition</b> tag_invoke.h:28</div></div>
<div class="ttc" id="anamespacedi_html_a1459d8183672803c685081823d4354cf"><div class="ttname"><a href="namespacedi.html#a1459d8183672803c685081823d4354cf">di::make_fields</a></div><div class="ttdeci">constexpr auto make_fields</div><div class="ttdef"><b>Definition</b> field.h:88</div></div>
<div class="ttc" id="anamespacedi_html_a6356665207ab38e1c7e6519f300312e8"><div class="ttname"><a href="namespacedi.html#a6356665207ab38e1c7e6519f300312e8">di::enumerator</a></div><div class="ttdeci">constexpr auto enumerator</div><div class="ttdef"><b>Definition</b> enumerator.h:40</div></div>
<div class="ttc" id="anamespacedi_html_a6fc25425a44d813af794d567f4764637"><div class="ttname"><a href="namespacedi.html#a6fc25425a44d813af794d567f4764637">di::field</a></div><div class="ttdeci">constexpr auto field</div><div class="ttdef"><b>Definition</b> field.h:46</div></div>
<div class="ttc" id="anamespacedi_html_a7c03bea911cd4e8bf769ea17b7246998"><div class="ttname"><a href="namespacedi.html#a7c03bea911cd4e8bf769ea17b7246998">di::make_enumerators</a></div><div class="ttdeci">constexpr auto make_enumerators</div><div class="ttdef"><b>Definition</b> enumerator.h:82</div></div>
<div class="ttc" id="areflect_2prelude_8h_html"><div class="ttname"><a href="reflect_2prelude_8h.html">prelude.h</a></div></div>
<div class="ttc" id="astructdi_1_1types_1_1InPlaceType_html"><div class="ttname"><a href="structdi_1_1types_1_1InPlaceType.html">di::types::InPlaceType</a></div><div class="ttdef"><b>Definition</b> in_place_type.h:5</div></div>
</div><!-- fragment --><p>If using a macro based approach to reflection, this would be equivalent to the following:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyType {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    <span class="keywordtype">int</span> y;</div>
<div class="line">    <span class="keywordtype">int</span> z;</div>
<div class="line"> </div>
<div class="line">    DI_RELECT(MyType, x, y, z);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">DI_DECLARE_ENUM(MyEnum, A, B, C);</div>
</div><!-- fragment --><p>This is definitely shorter, but it is also less flexible. For instance, it is not possible to use a different name for the fields (which could useful for JSON serialization, or because member variables have the 'm_' prefix). Additionally, the macro approach would require preprocessor iteration magic, which means there will be an upper bound to the number of fields which can be supported. And syntax errors when using the macro will result in utterly incomprehensible error messages.</p>
<p>For instance, here is an example of reflecting a class type with private member variables. Since the reflection is implemented using hidden friend functions, it is possible to access private members.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyClass {</div>
<div class="line">    <span class="keywordtype">int</span> m_x;</div>
<div class="line">    <span class="keywordtype">int</span> m_y;</div>
<div class="line">    <span class="keywordtype">int</span> m_z;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">constexpr</span> MyClass(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z) : m_x(x), m_y(y), m_z(z) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">int</span> x()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_x; }</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">int</span> y()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_y; }</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keywordtype">int</span> z()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_z; }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">friend</span> <span class="keyword">auto</span> <a class="code hl_variable" href="namespacedi_1_1function_1_1tag__invoke__ns.html#a191e794736625ce4bdaaadb02b15e0e1">tag_invoke</a>(<a class="code hl_typedef" href="namespacedi_1_1types.html#aced2939f1b335fd6ed3e3def9aff824e">di::Tag&lt;di::reflect&gt;</a>, di::InPlaceType&lt;MyClass&gt;) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="namespacedi.html#a1459d8183672803c685081823d4354cf">di::make_fields</a>&lt;<span class="stringliteral">&quot;MyClass&quot;</span>&gt;(<a class="code hl_variable" href="namespacedi.html#a6fc25425a44d813af794d567f4764637">di::field</a>&lt;<span class="stringliteral">&quot;x&quot;</span>, &amp;MyClass::m_x&gt;, <a class="code hl_variable" href="namespacedi.html#a6fc25425a44d813af794d567f4764637">di::field</a>&lt;<span class="stringliteral">&quot;y&quot;</span>, &amp;MyClass::m_y&gt;,</div>
<div class="line">                                          <a class="code hl_variable" href="namespacedi.html#a6fc25425a44d813af794d567f4764637">di::field</a>&lt;<span class="stringliteral">&quot;z&quot;</span>, &amp;MyClass::m_z&gt;);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> MyEnum { A, B, C };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <a class="code hl_variable" href="namespacedi_1_1function_1_1tag__invoke__ns.html#a191e794736625ce4bdaaadb02b15e0e1">tag_invoke</a>(<a class="code hl_typedef" href="namespacedi_1_1types.html#aced2939f1b335fd6ed3e3def9aff824e">di::Tag&lt;di::reflect&gt;</a>, <a class="code hl_struct" href="structdi_1_1types_1_1InPlaceType.html">di::InPlaceType&lt;MyEnum&gt;</a>) {</div>
<div class="line">    <span class="keyword">using </span>enum MyEnum;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_variable" href="namespacedi.html#a7c03bea911cd4e8bf769ea17b7246998">di::make_enumerators</a>&lt;<span class="stringliteral">&quot;MyEnum&quot;</span>&gt;(<a class="code hl_variable" href="namespacedi.html#a6356665207ab38e1c7e6519f300312e8">di::enumerator</a>&lt;<span class="stringliteral">&quot;MYENUM_A&quot;</span>, A&gt;, <a class="code hl_variable" href="namespacedi.html#a6356665207ab38e1c7e6519f300312e8">di::enumerator</a>&lt;<span class="stringliteral">&quot;MYENUM_B&quot;</span>, B&gt;,</div>
<div class="line">                                          <a class="code hl_variable" href="namespacedi.html#a6356665207ab38e1c7e6519f300312e8">di::enumerator</a>&lt;<span class="stringliteral">&quot;MYENUM_C&quot;</span>, C&gt;);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md100"></a>
Internal Representation</h1>
<p>The internal representation of a reflected type is an <code><a class="el" href="structdi_1_1reflection_1_1Fields.html">di::reflection::Fields</a></code> object. Each type member in the list corresponds to a field. Each field is a <code><a class="el" href="structdi_1_1reflection_1_1Field.html">di::reflection::Field</a></code> object, which contains a name and a pointer to the member. The <code>Fields</code> object inherits from <code><a class="el" href="classdi_1_1Tuple.html">di::Tuple</a></code>, and is thus easily convertible to a type-list. This lets compile time code use the existing type-list meta-programming tools. And at no additional cost, the <code>Fields</code> object can be used like a tuple.</p>
<p>Enumerations are also supported. For this case, the reflect type is an <code><a class="el" href="structdi_1_1reflection_1_1Enumerators.html">di::reflection::Enumerators</a></code> object. This is similar to the <code><a class="el" href="structdi_1_1reflection_1_1Fields.html">di::reflection::Fields</a></code> object, but instead of containing a list of fields, it contains a list of enumerators. Each enumerator is a <code><a class="el" href="structdi_1_1reflection_1_1Enumerator.html">di::reflection::Enumerator</a></code> object, which contains a name and a value. These can also be interacted with normally as a tuple.</p>
<p>These types have their information fully encoded in the type system, which means they effectively store no data. The field class simply looks as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;di::FixedString field_name, auto field_po<span class="keywordtype">int</span>er&gt;</div>
<div class="line"><span class="keyword">requires</span>(<a class="code hl_concept" href="conceptdi_1_1concepts_1_1MemberObjectPointer.html">di::concepts::MemberObjectPointer</a>&lt;<span class="keyword">decltype</span>(field_pointer)&gt;)</div>
<div class="line"><span class="keyword">struct</span> Field {</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> name = field_name;</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> pointer = field_pointer;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using </span>Object = <a class="code hl_typedef" href="namespacedi_1_1meta.html#accca3d0b7b76eee6c9f2cc0c4b66eb9b">di::meta::MemberPointerClass</a>&lt;<span class="keyword">decltype</span>(pointer)&gt;;</div>
<div class="line">    <span class="keyword">using </span>Type = <a class="code hl_typedef" href="namespacedi_1_1meta.html#a239481ab76429b7aae32925cbe5e7b42">di::meta::MemberPointerValue</a>&lt;<span class="keyword">decltype</span>(pointer)&gt;;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span>(<a class="code hl_concept" href="conceptdi_1_1concepts_1_1Invocable.html">di::concepts::Invocable</a>&lt;<span class="keyword">decltype</span>(pointer), T&gt;)</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">decltype</span>(<span class="keyword">auto</span>) get(T&amp;&amp; <span class="keywordtype">object</span>) {</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code hl_variable" href="namespacedi.html#a46f379b63dea01f4807a41faf6531f34">di::invoke</a>(pointer, di::forward&lt;T&gt;(<span class="keywordtype">object</span>));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aconceptdi_1_1concepts_1_1Invocable_html"><div class="ttname"><a href="conceptdi_1_1concepts_1_1Invocable.html">di::concepts::Invocable</a></div><div class="ttdef"><b>Definition</b> invoke.h:58</div></div>
<div class="ttc" id="aconceptdi_1_1concepts_1_1MemberObjectPointer_html"><div class="ttname"><a href="conceptdi_1_1concepts_1_1MemberObjectPointer.html">di::concepts::MemberObjectPointer</a></div><div class="ttdef"><b>Definition</b> language.h:203</div></div>
<div class="ttc" id="anamespacedi_1_1meta_html_a239481ab76429b7aae32925cbe5e7b42"><div class="ttname"><a href="namespacedi_1_1meta.html#a239481ab76429b7aae32925cbe5e7b42">di::meta::MemberPointerValue</a></div><div class="ttdeci">Type&lt; detail::MemberPointerValueHelper&lt; RemoveCV&lt; T &gt; &gt; &gt; MemberPointerValue</div><div class="ttdef"><b>Definition</b> language.h:184</div></div>
<div class="ttc" id="anamespacedi_1_1meta_html_accca3d0b7b76eee6c9f2cc0c4b66eb9b"><div class="ttname"><a href="namespacedi_1_1meta.html#accca3d0b7b76eee6c9f2cc0c4b66eb9b">di::meta::MemberPointerClass</a></div><div class="ttdeci">Type&lt; detail::MemberPointerClassHelper&lt; RemoveCV&lt; T &gt; &gt; &gt; MemberPointerClass</div><div class="ttdef"><b>Definition</b> language.h:195</div></div>
<div class="ttc" id="anamespacedi_html_a46f379b63dea01f4807a41faf6531f34"><div class="ttname"><a href="namespacedi.html#a46f379b63dea01f4807a41faf6531f34">di::invoke</a></div><div class="ttdeci">constexpr auto invoke</div><div class="ttdef"><b>Definition</b> invoke.h:100</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md101"></a>
Atoms</h2>
<p>The <code><a class="el" href="structdi_1_1reflection_1_1Atom.html">di::reflection::Atom</a></code> class is used to represent a primitive type which is not divisible into fields. For instance, integers, strings, and booleans are atoms. This enables reflection of these types, and will allow classes which are semantically equivalent to be treated as equivalent. For instance, an <code>int</code> and a <code><a class="el" href="classdi_1_1StrongInt.html">di::StrongInt</a>&lt;int, MyTag&gt;</code> can both reflect as an integer, and can be treated as equivalent.</p>
<h1><a class="anchor" id="autotoc_md102"></a>
Accessing Reflection Information</h1>
<p>The <code><a class="el" href="namespacedi.html#a8e12ec8d01827ce4f7c0738dc7a406cc">di::reflect</a></code> function can be used to access the reflection information for a type. Since this is a function, it will return the reflection information as a value which models <code>di::ReflectionValue</code>. For example, calling <code><a class="el" href="namespacedi.html#a8e12ec8d01827ce4f7c0738dc7a406cc">di::reflect(mytype_instance)</a></code> will return the custom <code><a class="el" href="structdi_1_1Fields.html">di::Fields</a></code> object the type defines. If a type is needed, <code><a class="el" href="namespacedi_1_1meta.html#a43d862c8a6330238881c0a09d1f06400">di::meta::Reflect</a>&lt;MyType&gt;</code> can be used instead. Since <code><a class="el" href="namespacedi.html#a8e12ec8d01827ce4f7c0738dc7a406cc">di::reflect()</a></code> can also return an <code><a class="el" href="structdi_1_1reflection_1_1Atom.html">di::reflection::Atom</a></code> or <code><a class="el" href="structdi_1_1reflection_1_1Enumerators.html">di::reflection::Enumerators</a></code> object, it is necessary to constrain functions on <code>di::ReflectableToFields</code> to in certain cases.</p>
<p>This can be used to implement various utilities. For instance, the following function can be used to print every member of a type:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> print_fields(di::ReflectableToFields <span class="keyword">auto</span> <span class="keyword">const</span>&amp; <span class="keywordtype">object</span>) {</div>
<div class="line">    <a class="code hl_function" href="namespacedi.html#a80b885a1556290dc281c56694cb5ffc7">di::tuple_for_each</a>(</div>
<div class="line">        [&amp;](<span class="keyword">auto</span> field) {</div>
<div class="line">            dius::println(<span class="stringliteral">&quot;{}: {}&quot;</span>, field.name, field.get(<span class="keywordtype">object</span>));</div>
<div class="line">        },</div>
<div class="line">        <a class="code hl_variable" href="namespacedi.html#a8e12ec8d01827ce4f7c0738dc7a406cc">di::reflect</a>(<span class="keywordtype">object</span>));</div>
<div class="line">}</div>
<div class="ttc" id="anamespacedi_html_a80b885a1556290dc281c56694cb5ffc7"><div class="ttname"><a href="namespacedi.html#a80b885a1556290dc281c56694cb5ffc7">di::tuple_for_each</a></div><div class="ttdeci">constexpr void tuple_for_each(F &amp;&amp;function, Tup &amp;&amp;tuple)</div><div class="ttdef"><b>Definition</b> tuple_for_each.h:22</div></div>
<div class="ttc" id="anamespacedi_html_a8e12ec8d01827ce4f7c0738dc7a406cc"><div class="ttname"><a href="namespacedi.html#a8e12ec8d01827ce4f7c0738dc7a406cc">di::reflect</a></div><div class="ttdeci">constexpr auto reflect</div><div class="ttdef"><b>Definition</b> reflect.h:47</div></div>
</div><!-- fragment --><p>Another example is hashing a type:</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> hash_fields(di::Hasher <span class="keyword">auto</span>&amp; hasher, di::ReflectableToFields <span class="keyword">auto</span> <span class="keyword">const</span>&amp; <span class="keywordtype">object</span>) {</div>
<div class="line">    <a class="code hl_function" href="namespacedi.html#a80b885a1556290dc281c56694cb5ffc7">di::tuple_for_each</a>(</div>
<div class="line">        [&amp;](<span class="keyword">auto</span> field) {</div>
<div class="line">            <a class="code hl_variable" href="namespacedi.html#adeeac51ef13ad7516e8307cd31b2a67c">di::hash_write</a>(hasher, field.get(<span class="keywordtype">object</span>));</div>
<div class="line">        },</div>
<div class="line">        <a class="code hl_variable" href="namespacedi.html#a8e12ec8d01827ce4f7c0738dc7a406cc">di::reflect</a>(<span class="keywordtype">object</span>));</div>
<div class="line">}</div>
<div class="ttc" id="anamespacedi_html_adeeac51ef13ad7516e8307cd31b2a67c"><div class="ttname"><a href="namespacedi.html#adeeac51ef13ad7516e8307cd31b2a67c">di::hash_write</a></div><div class="ttdeci">constexpr auto hash_write</div><div class="ttdef"><b>Definition</b> hash_write.h:43</div></div>
</div><!-- fragment --><p>For enums, we can get the name of an enumerator:</p>
<div class="fragment"><div class="line"><span class="comment">// NOTE: this is already defined by the library as `di::enum_to_string()`.</span></div>
<div class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> enum_to_string(di::ReflectableToEnumerators <span class="keyword">auto</span> value) {</div>
<div class="line">    <span class="keyword">auto</span> result = <span class="stringliteral">&quot;Invalid&quot;</span>_sv;</div>
<div class="line">    <a class="code hl_function" href="namespacedi.html#a80b885a1556290dc281c56694cb5ffc7">di::tuple_for_each</a>(</div>
<div class="line">        [&amp;](<span class="keyword">auto</span> enumerator) {</div>
<div class="line">            <span class="keywordflow">if</span> (enumerator.value == value) {</div>
<div class="line">                <span class="comment">// NOTE: the strings in this library are compile-time values (with fixed length), so we need to convert</span></div>
<div class="line">                <span class="comment">// them to a normal string view.</span></div>
<div class="line">                result = <a class="code hl_variable" href="namespacedi_1_1container.html#ae4b87691b9b1ce9cf9ce18773bcf24f9">di::container::fixed_string_to_utf8_string_view</a>&lt;enumerator.name&gt;();</div>
<div class="line">            }</div>
<div class="line">        },</div>
<div class="line">        <a class="code hl_variable" href="namespacedi.html#a8e12ec8d01827ce4f7c0738dc7a406cc">di::reflect</a>(value));</div>
<div class="line">    <span class="keywordflow">return</span> result;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacedi_1_1container_html_ae4b87691b9b1ce9cf9ce18773bcf24f9"><div class="ttname"><a href="namespacedi_1_1container.html#ae4b87691b9b1ce9cf9ce18773bcf24f9">di::container::fixed_string_to_utf8_string_view</a></div><div class="ttdeci">constexpr auto fixed_string_to_utf8_string_view</div><div class="ttdef"><b>Definition</b> fixed_string_to_utf8_string_view.h:32</div></div>
</div><!-- fragment --><p>Since the reflection information is stored in a tuple, it can be easily accessed without template metaprogramming. This should make it easier to implement various utilities.</p>
<h1><a class="anchor" id="autotoc_md103"></a>
Uses in library</h1>
<p>Providing static reflection information for a type enables several implementations in the library automatically. The current list is as follows:</p>
<ol type="1">
<li><code><a class="el" href="namespacedi_1_1format.html">di::format()</a></code> and <code><a class="el" href="namespacedi.html#a7ab61346e36f2b4c119644c031e9103a">di::to_string()</a></code> will use the reflection information to print the contents of a type or enum.</li>
<li><code><a class="el" href="namespacedi.html#adcc239d82cef689530da6b8b93adec6d">di::hash()</a></code> will use the reflection information to hash the contents of a type.</li>
<li><code><a class="el" href="namespacedi.html#a5e12bf0498447f6ab7ce4292209835c6">di::serialize()</a></code> will use the reflection information to serialize the contents of a type or enum.</li>
<li><code><a class="el" href="namespacedi.html#afc06908ae94cf039d1c2771bc765a066">di::parse()</a></code> will use the reflection information to parse an enum from a string.</li>
</ol>
<h1><a class="anchor" id="autotoc_md104"></a>
Limitations</h1>
<p>The current implementation has a few limitations. The main one is that it does not support inheritance. In some cases, is useful for a type to inherit the reflection information of a base type. For instance, a message type might inherit the reflection information of a base message type. Currently, this would require manually copying the reflection information from the base type to the derived type. This is not ideal, but it is not too bad.</p>
<p>The library also does not support reflecting member functions, but this can be added if a need arises. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="md_docs_2pages_2library__component__overview.html">Library Component Overview</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
